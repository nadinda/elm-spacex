-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module SpaceX.Subscription exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import SpaceX.Enum.Users_select_column
import SpaceX.InputObject
import SpaceX.Interface
import SpaceX.Object
import SpaceX.Scalar
import SpaceX.ScalarCodecs
import SpaceX.Union


type alias UsersOptionalArguments =
    { distinct_on : OptionalArgument (List SpaceX.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List SpaceX.InputObject.Users_order_by)
    , where_ : OptionalArgument SpaceX.InputObject.Users_bool_exp
    }


{-| fetch data from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the nuber of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users :
    (UsersOptionalArguments -> UsersOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Users
    -> SelectionSet (List decodesTo) RootSubscription
users fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum SpaceX.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (SpaceX.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ SpaceX.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias UsersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List SpaceX.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List SpaceX.InputObject.Users_order_by)
    , where_ : OptionalArgument SpaceX.InputObject.Users_bool_exp
    }


{-| fetch aggregated fields from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the nuber of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users_aggregate :
    (UsersAggregateOptionalArguments -> UsersAggregateOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Users_aggregate
    -> SelectionSet decodesTo RootSubscription
users_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum SpaceX.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (SpaceX.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ SpaceX.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users_aggregate" optionalArgs____ object____ Basics.identity


type alias UsersByPkRequiredArguments =
    { id : SpaceX.ScalarCodecs.Uuid }


{-| fetch data from the table: "users" using primary key columns

  - id -

-}
users_by_pk :
    UsersByPkRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Users
    -> SelectionSet (Maybe decodesTo) RootSubscription
users_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "users_by_pk" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)
