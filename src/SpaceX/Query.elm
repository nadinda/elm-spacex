-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module SpaceX.Query exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import SpaceX.Enum.Users_select_column
import SpaceX.InputObject
import SpaceX.Interface
import SpaceX.Object
import SpaceX.Scalar
import SpaceX.ScalarCodecs
import SpaceX.Union


type alias UsersOptionalArguments =
    { distinct_on : OptionalArgument (List SpaceX.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List SpaceX.InputObject.Users_order_by)
    , where_ : OptionalArgument SpaceX.InputObject.Users_bool_exp
    }


{-| fetch data from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the nuber of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users :
    (UsersOptionalArguments -> UsersOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Users
    -> SelectionSet (List decodesTo) RootQuery
users fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum SpaceX.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (SpaceX.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ SpaceX.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias UsersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List SpaceX.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List SpaceX.InputObject.Users_order_by)
    , where_ : OptionalArgument SpaceX.InputObject.Users_bool_exp
    }


{-| fetch aggregated fields from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the nuber of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users_aggregate :
    (UsersAggregateOptionalArguments -> UsersAggregateOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Users_aggregate
    -> SelectionSet decodesTo RootQuery
users_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum SpaceX.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (SpaceX.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ SpaceX.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users_aggregate" optionalArgs____ object____ Basics.identity


type alias UsersByPkRequiredArguments =
    { id : SpaceX.ScalarCodecs.Uuid }


{-| fetch data from the table: "users" using primary key columns

  - id -

-}
users_by_pk :
    UsersByPkRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Users
    -> SelectionSet (Maybe decodesTo) RootQuery
users_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "users_by_pk" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias CapsulesOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CapsulesFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
capsules :
    (CapsulesOptionalArguments -> CapsulesOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Capsule
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
capsules fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCapsulesFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "capsules" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CapsulesPastOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CapsulesFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
capsulesPast :
    (CapsulesPastOptionalArguments -> CapsulesPastOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Capsule
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
capsulesPast fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCapsulesFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "capsulesPast" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CapsulesUpcomingOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CapsulesFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
capsulesUpcoming :
    (CapsulesUpcomingOptionalArguments -> CapsulesUpcomingOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Capsule
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
capsulesUpcoming fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCapsulesFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "capsulesUpcoming" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CapsuleRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
capsule :
    CapsuleRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Capsule
    -> SelectionSet (Maybe decodesTo) RootQuery
capsule requiredArgs____ object____ =
    Object.selectionForCompositeField "capsule" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


{-| -}
company :
    SelectionSet decodesTo SpaceX.Object.Info
    -> SelectionSet (Maybe decodesTo) RootQuery
company object____ =
    Object.selectionForCompositeField "company" [] object____ (Basics.identity >> Decode.nullable)


type alias CoresOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CoresFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
cores :
    (CoresOptionalArguments -> CoresOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Core
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
cores fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCoresFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "cores" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CoresPastOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CoresFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
coresPast :
    (CoresPastOptionalArguments -> CoresPastOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Core
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
coresPast fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCoresFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "coresPast" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CoresUpcomingOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.CoresFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
coresUpcoming :
    (CoresUpcomingOptionalArguments -> CoresUpcomingOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Core
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
coresUpcoming fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeCoresFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "coresUpcoming" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias CoreRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
core :
    CoreRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Core
    -> SelectionSet (Maybe decodesTo) RootQuery
core requiredArgs____ object____ =
    Object.selectionForCompositeField "core" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias DragonsOptionalArguments =
    { limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - limit -
  - offset -

-}
dragons :
    (DragonsOptionalArguments -> DragonsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Dragon
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
dragons fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "dragons" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias DragonRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
dragon :
    DragonRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Dragon
    -> SelectionSet (Maybe decodesTo) RootQuery
dragon requiredArgs____ object____ =
    Object.selectionForCompositeField "dragon" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias HistoriesOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.HistoryFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
histories :
    (HistoriesOptionalArguments -> HistoriesOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.History
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
histories fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeHistoryFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "histories" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias HistoriesResultOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.HistoryFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
historiesResult :
    (HistoriesResultOptionalArguments -> HistoriesResultOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.HistoriesResult
    -> SelectionSet (Maybe decodesTo) RootQuery
historiesResult fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeHistoryFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "historiesResult" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias HistoryRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
history :
    HistoryRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.History
    -> SelectionSet (Maybe decodesTo) RootQuery
history requiredArgs____ object____ =
    Object.selectionForCompositeField "history" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias LandpadsOptionalArguments =
    { limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - limit -
  - offset -

-}
landpads :
    (LandpadsOptionalArguments -> LandpadsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Landpad
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
landpads fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "landpads" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias LandpadRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
landpad :
    LandpadRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Landpad
    -> SelectionSet (Maybe decodesTo) RootQuery
landpad requiredArgs____ object____ =
    Object.selectionForCompositeField "landpad" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias LaunchesOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.LaunchFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
launches :
    (LaunchesOptionalArguments -> LaunchesOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
launches fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeLaunchFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launches" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias LaunchesPastOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.LaunchFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
launchesPast :
    (LaunchesPastOptionalArguments -> LaunchesPastOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
launchesPast fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeLaunchFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchesPast" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias LaunchesPastResultOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.LaunchFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
launchesPastResult :
    (LaunchesPastResultOptionalArguments -> LaunchesPastResultOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.LaunchesPastResult
    -> SelectionSet (Maybe decodesTo) RootQuery
launchesPastResult fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeLaunchFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchesPastResult" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias LaunchesUpcomingOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.LaunchFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
launchesUpcoming :
    (LaunchesUpcomingOptionalArguments -> LaunchesUpcomingOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
launchesUpcoming fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeLaunchFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchesUpcoming" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias LaunchRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
launch :
    LaunchRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe decodesTo) RootQuery
launch requiredArgs____ object____ =
    Object.selectionForCompositeField "launch" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias LaunchLatestOptionalArguments =
    { offset : OptionalArgument Int }


{-|

  - offset -

-}
launchLatest :
    (LaunchLatestOptionalArguments -> LaunchLatestOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe decodesTo) RootQuery
launchLatest fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { offset = Absent }

        optionalArgs____ =
            [ Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchLatest" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias LaunchNextOptionalArguments =
    { offset : OptionalArgument Int }


{-|

  - offset -

-}
launchNext :
    (LaunchNextOptionalArguments -> LaunchNextOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launch
    -> SelectionSet (Maybe decodesTo) RootQuery
launchNext fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { offset = Absent }

        optionalArgs____ =
            [ Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchNext" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias LaunchpadsOptionalArguments =
    { limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - limit -
  - offset -

-}
launchpads :
    (LaunchpadsOptionalArguments -> LaunchpadsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Launchpad
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
launchpads fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "launchpads" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias LaunchpadRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
launchpad :
    LaunchpadRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Launchpad
    -> SelectionSet (Maybe decodesTo) RootQuery
launchpad requiredArgs____ object____ =
    Object.selectionForCompositeField "launchpad" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias MissionsOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.MissionsFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - find -
  - limit -
  - offset -

-}
missions :
    (MissionsOptionalArguments -> MissionsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Mission
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
missions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeMissionsFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "missions" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias MissionsResultOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.MissionsFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - find -
  - limit -
  - offset -

-}
missionsResult :
    (MissionsResultOptionalArguments -> MissionsResultOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.MissionResult
    -> SelectionSet (Maybe decodesTo) RootQuery
missionsResult fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeMissionsFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "missionsResult" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias MissionRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
mission :
    MissionRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Mission
    -> SelectionSet (Maybe decodesTo) RootQuery
mission requiredArgs____ object____ =
    Object.selectionForCompositeField "mission" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias PayloadsOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.PayloadsFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
payloads :
    (PayloadsOptionalArguments -> PayloadsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Payload
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
payloads fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodePayloadsFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "payloads" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias PayloadRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
payload :
    PayloadRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Payload
    -> SelectionSet (Maybe decodesTo) RootQuery
payload requiredArgs____ object____ =
    Object.selectionForCompositeField "payload" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


{-| -}
roadster :
    SelectionSet decodesTo SpaceX.Object.Roadster
    -> SelectionSet (Maybe decodesTo) RootQuery
roadster object____ =
    Object.selectionForCompositeField "roadster" [] object____ (Basics.identity >> Decode.nullable)


type alias RocketsOptionalArguments =
    { limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - limit -
  - offset -

-}
rockets :
    (RocketsOptionalArguments -> RocketsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Rocket
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
rockets fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rockets" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias RocketsResultOptionalArguments =
    { limit : OptionalArgument Int
    , offset : OptionalArgument Int
    }


{-|

  - limit -
  - offset -

-}
rocketsResult :
    (RocketsResultOptionalArguments -> RocketsResultOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.RocketsResult
    -> SelectionSet (Maybe decodesTo) RootQuery
rocketsResult fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { limit = Absent, offset = Absent }

        optionalArgs____ =
            [ Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rocketsResult" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias RocketRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
rocket :
    RocketRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Rocket
    -> SelectionSet (Maybe decodesTo) RootQuery
rocket requiredArgs____ object____ =
    Object.selectionForCompositeField "rocket" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias ShipsOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.ShipsFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
ships :
    (ShipsOptionalArguments -> ShipsOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.Ship
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
ships fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeShipsFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "ships" optionalArgs____ object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias ShipsResultOptionalArguments =
    { find : OptionalArgument SpaceX.InputObject.ShipsFind
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order : OptionalArgument String
    , sort : OptionalArgument String
    }


{-|

  - find -
  - limit -
  - offset -
  - order -
  - sort -

-}
shipsResult :
    (ShipsResultOptionalArguments -> ShipsResultOptionalArguments)
    -> SelectionSet decodesTo SpaceX.Object.ShipsResult
    -> SelectionSet (Maybe decodesTo) RootQuery
shipsResult fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { find = Absent, limit = Absent, offset = Absent, order = Absent, sort = Absent }

        optionalArgs____ =
            [ Argument.optional "find" filledInOptionals____.find SpaceX.InputObject.encodeShipsFind, Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order" filledInOptionals____.order Encode.string, Argument.optional "sort" filledInOptionals____.sort Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "shipsResult" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ShipRequiredArguments =
    { id : SpaceX.ScalarCodecs.Id }


{-|

  - id -

-}
ship :
    ShipRequiredArguments
    -> SelectionSet decodesTo SpaceX.Object.Ship
    -> SelectionSet (Maybe decodesTo) RootQuery
ship requiredArgs____ object____ =
    Object.selectionForCompositeField "ship" [ Argument.required "id" requiredArgs____.id (SpaceX.ScalarCodecs.codecs |> SpaceX.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)
